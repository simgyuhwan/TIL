# 스프링 컨테이너의 기본전략

스프링 컨테이너는 **영속성 컨텍스트의 범위**는 **트랜잭션 범위**까지를 사용하는 것을 기본 전략으로 둔다. 즉, 트랜잭션을 시작할 때, 영속성 컨텍스트를 생성하고 트랜잭션이 끝나면 영속성 컨택스트도 종료된다. 

이런 영속성 컨텍스트는 다음과 같은 특징을 가진다. 

- 같은 트랜잭션은 **같은 영속성 컨텍스트를 공유**한다. 다른 트랜잭션은 다른 영속성 컨택스트
- 트랜잭션이 끝날 때, 영속성 컨택스트는 **변경 내용을 데이터베이스에 flush** 하고 **트랜잭션을 커밋**한다.

# 준영속 상태와 지연로딩

위에서 말한 것처럼 영속성 컨텍스트의 범위는 트랜잭션 범위 내이다. 일반적으로 트랜잭션은 서비스 계층부터 시작되는데. 서비스 계층에서 커밋을 완료하고 **컨트롤러 계층에 반환했을 때**는 **영속성 컨텍스트는 종료된 상태**가 된다. 그러면 조회된 엔티티는 **준영속 상태**가 되고 만약 **Lazy Loading** 된 엔티티을 조회하려고 하면 에러를 발생시킨다. **(LazyInitializationException)**

그러면 엔티티를 미리 로딩을 해야 하는데. 방법은 3가지가 있다. 

- 글로벌 페치 전략 수정
- JPQL 페치 조인
- 강제로 초기화

## 1. 글로벌 페치 전략 수정

먼저 언급한 문제를 해결하기 위한 방법 중 하나는 지연 로딩을 **즉시 로딩으**로 변경하면 된다. fetch 타입을 변경하는 것을 글로벌 페치 전략이라고 한다.

```java
@ManyToOne(fetch = FetchType.EAGER)
private Member member; // 주문 회원
```

### 글로벌 페치 전략시 단점

- 사용하지 않는 엔티티를 로딩한다.
- N+1 발생

## 2. JPQL 페치 조인

페치 조인을 사용하면 **`N + 1`**을 해결할 수 있다. 

```java
JPQL : select o from Order o join fetch o.member
SQL : select o.*, m.* from Order o join Member m on.MEMBER_ID=m.MEMBER_ID
```

### JPQL 페치 조인의 단점

페치 조인을 사용하면 `N + 1` 을 해결할 수 있지만 뷰에 대한 의존성이 생기게 된다. 예를 들어, 화면 **A**에는 Order만 필요하고 화면 **B**에는 Order, Member가 필요하다고 해보자. 각 화면에 맞춰 메소드를 만든다면

`repository.findOrder(), repository.findOrderWithMember()`

두 개가 나올 것이다. 이제 화면에 맞게 각 메소드를 호출하면 된다. 이렇게 하면 메서드당 최적화는 가능하지만 뷰와 리포지토리 간의 **논리적 의존관계**가 생기게 된다. 

대안으로는 repository.findOrder() 를 페치 조인으로 구성하여 하나의 메서드로 통일할 수 있는데. Order만 필요한 화면에는 약간의 지연이 있게지만 계층간의 의존 관계가 생기는 것보다는 나을 수 있다.

## 3. 강제로 초기화

강제로 초기화는 영속성 컨텍스트가 아직 살아있을 때, 필요한 객체를 초기화 하는 것이다. 글로벌 페치는 Lazy로 가정한다.

```java
class OrderService {
	
	@Transactional
	public Order findOrder(id) {
		Order order = orderRepository.findOrder(id);
		**order.getMember().getName(); // 프록시 객체를 강제로 초기화한다.**
		return order;
	}
}
```

서비스 계층에서 뷰에 필요한 프록시 객체를 강제로 초기화하는 방식인데. 이는 프리젠테이션 계층이 서비스 계층까지 침범하는 것과 같다. 서비스 계층은 비즈니스 로직만 있어야 하는데. 프리젠테이션 계층의 일까지 같이 하는 것은 좋지 않다. 

대안으로는 **파사드 계층**을 추가하는건데. 프리젠테이션 계층과 서비스 계층 사이에 파사드 계층을 두고 프리젠테이션 계층에 필요한 프록시를 초기화한다. 

트랜잭션의 시작은 파사드 계층부터 시작해야 한다. 다만 결과적으로 하나의 계층을 추가하는 것이고 이 계층에는 강제로 초기화하는 코드만 많을것이다.

# OSIV(Open session in view)

**OSIV**는 영속성 컨텍스트를 뷰까지 열어둔다는 뜻인데. 기존에는 트랜잭션 범위 즉, 서비스 계층까지 영속성 컨텍스트가 있었지만 **필터, 인터셉트까지 영속성 컨텍스트를 연장**한다.

과거의 OSIV는 이러한 연장이 한 가지 문제가 발생했는데. 영속성 컨택스트를 뷰까지 연장하면서 컨트롤러에서 엔티티의 변경이 발생하면 실제 DB에도 변경이 된다는 것이다.

이 문제를 해결하기 위해서 세 가지 대안이 있는데. 

- 엔티티를 읽기 전용 인터페이스로 제공
- 엔티티 래핑
- DTO 반환

모든 방법이 나쁘지 않다. 다만 추가적인 코드 생성이 있을 뿐이다. 

이러한 문제를 해결하기 위해서 **스프링에서 OSIV** 제공했는데.

## 1. 스프링 OSIV

스프링 OSIV와 기존 OSIV의 차이는 트랜잭션의 범위이다. 스프링 OSIV는 트랜잭션을 서비스 계층까지만 둔다. 그리고 영속성 컨텍스트는 동일하게 뷰까지 진행한다. 범위는 인터셉터, 필터 중 원하는 범위로 설정하면 된다. 

이렇게 범위를 서비스 계층으로 둠으로써, **서비스 계층에서 트랜잭션을 커밋하고 플러시를 한 뒤** 컨트롤러에 반환하기 때문에 컨트롤러에서 코드를 변경해도 실제로 반영되지 않는다. 

억지로 컨트롤러에서 플러시를 진행하면 **예외가 발생**한다.

트랜잭션이 없어 변경은 불가능하지만 영속성 컨텍스트 범위 내에 있기 때문에 엔티티를 **레이지 로딩이 가능하다.**

다만 **한 가지 문제**가 있는데. 

영속성 컨텍스트가 뷰까지 있기 때문에 엔티티를 변경하면 영속성 컨텍스트에 저장된다. 그리고 또 **다른 서비스 계층을 시작**하면 영속성 컨텍스트가 결합되면서 변경된 엔티티가 플러시 된다. 

이를 위해서 서비스 계층은 사전에 모두 진행하고 엔티티를 변경하라.