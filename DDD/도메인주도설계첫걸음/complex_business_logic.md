# 도메인 모델 패턴

**도메인 모델 패턴**의 중요한 한 가지는 비즈니스 로직을 다루기 위함이라는 것이다. 단순한 CRUD 인터페이스 대신 복잡한 상태 전환이나 항상 보호해야 하는 비즈니스 규칙을 이 도메인 모델이 담당하게 한다. 이 도메인 모델에는 인프라와 같이 기술적인 요소는 제외시킨다. 

## 구현

DDD의 도메인 모델의 구성요소는 다음과 같다. **에그리게이트, 벨류 오브젝트, 도메인 서비스, 도메인 이벤트**이다. **도메인 모델**은 **상태**와 **행동**을 가지고 있는 객체 모델이다. 

## 복잡성

도메인 비즈니스 로직은 충분히 **복잡한** 상태이다. 그 자체로도 복잡하기 때문에 기술적인 관심사인 인프라 영역인 프레임워크, 데이터베이스, 외부 영역 호출 등과 같은 영역과 분리해야 한다.

이런 제약을 가진 객체는 **Plain Old Object** 가 된다. 

<aside>
💡 **Plain Old Object**는 특정 프레임워크나 기술에 종속되지 않는 단순한 객체를 말한다.

</aside>

## 유비쿼터스 언어

기술적인 관심사를 제외하여 비즈니스 로직에 집중하게 하면 유비쿼터스 언어의 용어를 따르기 쉬워진다. 예를 들어, 기술적인 관심사가 들어가면 유비쿼터스 언어를 코드로 표현하는데 기술적 관심사가 관여하기 때문에 코드의 자유도가 떨어질 수 있기 때문이다.

# 구성 요소

도메인 모델 패턴의 구성 요소인 벨류 오브젝트, 에그리게이트, 도메인 서비스, 도메인 이벤트를 살펴보자. 

## 벨류 오브젝트

**Value Object**는 이름 그대로 값 객체이다. 값을 수식하기 위한 객체로 식별 값이 아닌 **그 자체로 식별자의 역할**을 하는 **불변 객체**를 의미한다. 

```java
// 색을 표현하는 객체
class Color {
	int red;
	int blud;
	int green;
}
```

색이란 빨간색, 파란색, 초록색의 비율에 따라 달라진다. 만약 빨,파,초의 비율이 같다면 같은 객체라고 볼 수 있다. 그 필드의 값들로 식별이 가능하기 때문에 식별 값은 필요 없다.

### 벨류 오브젝트 예시

다음은 손님에 대한 클래스이다. 

```java
class Customer {
	private int id;
	private String firstName;
	private String lastName;
	private String mobilePhone;
	private String landlinePhone;
	private String email;
	private String countryCode;
	....
}
```

각각은 원시타입인 String으로 구성되어 있다. 만약 countryCode, email 등 각각 형식이 맞는지 **유효성 검사**를 진행하려면 어떻게 해야할까?

생성자 혹은 메서드를 통해서 검증을 하게 될 것이다. 이 방법은 결국 중복 코드를 만들게 된다. 예를 들어, Customer 가 아닌 Supplier 객체가 하나 더 있다고 해보자. 그러면 이 객체에도 똑같은 유효성 검증이 추가가 될 것이다. 결국에는 코드를 수정하려면 동일하게 사용된 코드들 모두 찾아 수정해야하는 수고가 생긴다. 

이때 사용되는 것이 **벨류 오브젝트**이다. 

```java
class Customer {
	private PersonId id;
	private Name name;
	private PhoneNumber landline;
	private PhooneNumber mobile;
	private Email email;
	private CountryCode country; 
  ..
}
```

각 속성을 객체로 분리했다. 이제 객체들은 자신이 가진 값들의 유효성 검사라는 책임을 가지된다. 또 객체 자체가 유비쿼터스 언어를 표현하는 수단이 된다. 단순히 String으로 담았던 필드를 객체로 변경함으로써 유비쿼터스 언어의 속성을 표현하는 객체로 바꿀 수 있게 된다. 

또 객체를 분리하고 정적 메서드 패턴을 사용함에 따라 더욱 풍부한 표현이 가능해진다. 

```java
var phone = PhoneNumber.Parse("+359877123503");
var country = phone.Country; // 핸드폰 번호에서 국제번호 추출
var phoneType = phone.PhoneType;
var isValid = PhoneNumber.IsValid("+97212026680"); // 벨류 오브젝트로 유효성 검증

// 색 객체
var red = Color.FromRGB(255, 0, 0);
var green = Color.Green;
```

벨류 오브젝트를 사용함으로써 더 직관적인 객체 모델을 사용할 수 있게 된다.

## 엔티티

**엔티티**는 벨류 오브젝트와 반대이다. 엔티티는 반드시 식별자 값이 있어야 한다. 이 식별자 값은 불변이며 이 값을 통해 엔티티를 구분한다. 그렇기 때문에 다른 필드들이 동일할 수 있다. 또 벨류 오브젝트와 다르게 불변이 아니라 계속 상태가 바뀐다고 가정한다.

하지만 **엔티티는 단독으로 구성되지 않고 에그리게이트의 한 요소**로 구현한다.

### 에그리게이트

**에그리게이트**는 엔티티이다. 식별 값이 필요하며 상태가 계속 바뀔 수 있다. 그러면 에그리게이트는 무슨 차이가 있는 것일까? 에그리게이트의 주 목적은 데이터의 일관성 유지이다. 데이터는 변하게 된다. 일관성을 유지하기 위한 **경계**가 필요한데. 그것이 에그리게이트이다. 

**일관성 강화**

일관성을 강화하기 위해서는 어떻게 해야할까? 에그리게이트의 객체의 상태는 바뀌게 된다. 만약 상태를 바꿀 수 있는 루트가 여러 곳이라면 경계는 약해지게 되고 일관성을 지키기 힘들어진다. 

하지만 에그리게이트가 공개한 인터페이스를 통해서만 변경이 가능하게 하면 추적과 유효성 검증, 일관성 유지를 위한 경계를 강화할 수 있게 된다. 즉, **상태의 변화는 오직 에그리게이트의 비즈니스 로직을 통해서만 가능하게 한다**.

 

에그리 게이트의 퍼블릭 인터페이스로 노출된 상태 변경 메서드를 **커맨드**라고 부르는데. 이 커맨드는 두 가지 방식으로 구현할 수 있다. 

**인터페이스를 통한(메시지) 표현 방식**

AddMessage 라는 메시지와 매개변수를 사용해서 행위를 표현한다. 

```java
public class Example {
	...

	public void AddMessage(UserId from, string body) {
		var message = new Message(from, body);
		messages.Append(message);
	}
}
```

**파라미터 객체로 표현하는 방식**

모든 실행은 Execute를 통한다. 그리고 매개변수의 타입에 의해서 행위를 정한다.

```java
public class Example {
	...

	public void Execute(AddMessage cmd) {
		var message = new Message(cmd.from, cmd.body);
		messages.Append(message);
	}
}
```

**트랜잭션 경계**

에그리게이트 자체는 비즈니스 로직을 통해서만 수정될 수 있기 때문에 트랜잭션 경계의 역할을 한다. 모든 에그리게이트의 상태 변경은 원자적인 단일 오퍼레이션으로 트랜잭션 처리를 해야 한다. 쉽게 말해 하나의 에그리게이트는 하나의 트랜잭션을 담당하게 한다.

이러한 제약을 통해 에그리게이트 설계를 신중하게 하게 된다. 한 번의 트랜잭션으로 처리해야 할 엔티티가 있다면 하나의 에그리게이트로 묶어야 한다. 또 다른 장점으로는 일관성 있는 상태를 한 곳으로 묶을 수 있게 된다. 

가능하면 에그리게이트는 에그리게이트를 작게 유지하고 일관적으로 유지할 수 있는 필요한 객체만 담자.

**에그리게이트 루트**

에그리게이트의 상태는 커맨드를 통해서만 수정할 수 있게 한다. 에그리게이트 내에 하나의 엔티티를 선정하여  상태의 변경은 에그리게이트 루트를 통해서만 가능하도록 하자.

### 도메인 이벤트

**도메인 이벤트**는 비즈니스 도메인에서 일어나는 중요한 이벤트를 설명하는 **메시지**이다. 비즈니스 도메인에서 일어난 일을 과거형으로 표현한다. 표현할 때는 명확하고 간결하게 나타낸다. 그리고 이벤트에 필요한 모든 정보를 제공한다.  

```java
public class Ticket {
	private List<DomainEvent> domainEvents;
	...

	public void Execute(RequestEscalation cmd) {
		...
		var escalatedEvent = new TicketEscalated(id, cmd.Reason); // 이벤트 생성
		domainEvents.Append(escalatedEvent);  // 이벤트 발행
	}
	
}
```

위와 같이 생성되고 발행된 이벤트는 비즈니스 도메인 영역이나 그 밖의 외부 영역으로 전달된다. 

### 도메인 서비스

에그리게이트는 하나의 트랜잭션을 가진다고 했다. 하지만 에그리게이트 하나만 사용되는 상황만 생기지는 않는다. 여러 개의 에그리게이트를 관리할 수 있을텐데. 이때 사용되는 것이 **도메인 서비스**이다.

**도메인 서비스**는 상태가 없는 객체이다. 대부분의 경우, 어떤 계산이나 분석을 위해 다양한 에그리게이트나 외부 요소들을 호출해서 처리한다. 

도메인 서비스는 비즈니스 로직을 수행하기 위한 것이지 그 자체로 에그리게이트를 수정해서는 안된다. 수정의 역할은 에그리게이트 안에 둬야한다.