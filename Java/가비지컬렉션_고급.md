# 트레이드오프와 탈착형 수집기

가비지 수집기 선정 시 중요한 요인은 다음과 같다.

- **중단 시간**
- **처리율(애플리케이션 런타임 대비 GC 시간 %)**
- **중단 빈도**
- **회수 효율**
- **중단 일관성**

이 중 단연 최고의 관심사는 **중단 시간**이지만 그렇다고 이것만 관심을 가져서는 안된다. 만약 대용량 배치와 같은 작업은 중단 시간보다 중요한 것이 **처리율**이다. 이런 작업은 중단이 조금 더 걸려도 크게 상관이 없다. 

# 동시 GC 이론

GC의 큰 이슈는 언제 시작될지 알 수가 없다는 것이다. **불확정적**으로 STW 중단을 해결하기 위해 **동시 수집기**를 사용하여 애플리케이션 스레드의 실행 도중에 수집에 필요한 작업 일부를 수행해서 중단 시간을 줄이는 것도 한 방법이다.

다만, 그만큼 실제 애플리케이션 작업에 투입 가능한 처리 역량을 빼앗기고 수집하는 코드 로직은 복잡해진다. 

## JVM 세이프 포인트

STW 가비지 수집을 하려면 애플리케이션 스레드를 모두 중단시켜야 하는데. JVM은 어떻게 일을 할까? 

JVM에서는 스레드에 **세이프 포인트(safepoint)**라는 특별한 실행 지점을 설정해준다. 세이프 포인트란 각 스레드 별로 특정한 지점을 정해두고 이 지점을 도달하면 모든 스레드를 일시 중지시킨다.

JVM은 세이프 포인트에 대해서 두 가지 특징을 가지는데. 

- **JVM은 강제로 스레드를 세이프포인트 상태로 바꿀 수 없다.**
- **JMM은 스레드가 세이프포인트 상태에서 벗어나지 못하게 할 수 있다.**

첫 번째 JVM은 정해둔 세이프포인트에 도달할 때까지 기다려야 한다. 임의로 모든 스레드를 중단시키거나 할 수 없다.

두 번째 한 번 중단된 스레드들을 작업이 끝날 때까지 세이프포인트 상태에서 벗어나지 못하게 할 수 있다. 즉, 스레드가 세이프포인트에서 자발적으로 다른 코드로 넘어가거나 GC를 방해하거나 할 수없다. 

이러한 작업을 위해 스레드가 제어권을 반납하는 코드가 VM 인터프린터 구현체 어딘가 있어야 한다. 작업의 순서는 다음과 같다.

1. **JVM이 전역 세이프 포인트 시간(time to safepoint) 플래그를 세팅한다.**
2. **각 애플리케이션 스레드는 폴링하면서 이 플래그가 세팅됐는지 확인한다.**
3. **플래그가 세팅됐으면 스레드는 멈춘다.**

## 삼색 마킹(tri-color marking)

삼색 마킹은 회색, 흰색 검정색이 사용된다. 각 색의 특징은 다음과 같다. 

- **회색** : 접근해야할 객체
- **검정색**: 접근한 객체(살아있는 객체)
- **흰색**: 회수할 객체

그러면 이 색을 어떻게 삼색 알고리즘이 활용하는지 확인해보자.

1. **모든 객체를 흰색으로 표시한다.**
2. **GC 루트를 회색으로 표시한다.**
3. **랜덤으로 회색으로 이동하여 참조된 객체로 이동한다.**
4. **먼저 이동했던 회색은 검정색으로 바꾸고 참조된 객체는 회색으로 바꾼다.**
5. **3-4 를 반복한다.**
6. **흰색노드는 죽어있는 객체이므로 수집 대상이 된다.** 

이러한 동시 수집시, 문제가 발생할 수 있는데. 삼색을 모두 마킹한 다음에 갑자기 새로운 객체가 생성되어 흰색으로 표시된 객체를 참조하면 어떻게 될까?

흰색은 회수해야할 객체이므로 사용중에 객체가 제거될 경우가 생길 수 있다. 이러한 일을 방지하기 위해서 업데이트시 ‘**쓰기 베리어**’를 사용한다. 스레드가 새로운 객체를 생성할 때, 객체 색을 검정색으로 바꾸고 참조한 객체를 회색으로 바꿔준다.

## CMS

CMS는 테뉴어드 공간 전용 수집기이다. 중단 시간을 최소화하기 위해 사용되지만 그만큼 비용이 발생한다. 

마킹은 삼색 마킹 알고리즘에 따라 수행된다. 순서는 다음과 같다.

1. **초기 마킹** : 초기 마킹 단계는 GC 루트로 부터 도달할 수 있는 객체를 표시하기 위해 필요하다. 이때는 모든 **STW**가 적용되며 회색으로 표시되면 GC 루트로 부터 도달할 수 있는 객체라는 표시다
2. **동시 마킹** : **STW**가 풀리고 애플리케이션과 함께 삼색 알고리즘 마킹이 수행된다. 
3. **재마킹** : 다시 **STW**가 적용된다. 동시 마킹 중간에 새로운 객체가 생길 수 있고 이때 쓰기 베리어를 통해 변경된 객체들을 추적하고 올바른지 확인한다.
4. **동시 정리** : **STW**가 풀리고 애플리케이션과 함께 흰색 객체를 정리한다.  

모든 애플리케이션이 일시중지되는 곳은 초기마킹과 재마킹때이다. 긴 STW 시간을 짧게 두 번가지는 것으로 대체한 셈이다.

하지만 CMS를 수행할 때의 단점이 있다. GC 수행에 훨씬 **더 많은 CPU** 시간이 필요하고 힙을 압착하지 않으므로 테뉴어드 영역은 **단편화**될 수 있다. 그리고 GC가 객체를 추적해야 하므로 **메모리를 더 사용**하고 GC 사이클이 실행되는 동안 **애플리케이션 처리율이 감소**한다.

### CMS 작동 원리

CMS는 대부분 애플리케이션 스레드와 동시에 작동한다. 가용 스레드 절반을 동원해서 GC 동시 단계를 수행하고, 나머지는 자바 코드를 실행하는 데 쓰인다.

그런데 도중 에덴 공간이 꽉 차게 되면 어떻게 될까? 할당률이 급증하게 되면 더이상 할당할 곳이 없기 때문에 **조기 승격**이 이루어질 수 있다. 그러다보면 테뉴어드도 꽉 차게 되는데. 

이런 현상을 **동시 모드 실패(concurrent mode failure)** 라고 한다. 이때 JVM은 어쩔 수 없이 풀 STW를 유발하는 **ParallelOld GC 수집 방식**으로 돌아간다.

CMF가 일어나는 원인 중 하나는 CMS가 힙을 압착하지 않는다는 것에 있다. 이를 해결하기 위해 CMS는 내부적으로 프리 리스트라를 이용해서 빈 공간을 관리한다. **동시 정리 단계**에서 빈 공간들을 단편화가 되지 않기 위해 연속된 빈 블록으로 뭉친다.

동시 마킹 단계에서 변경자가 새로 할당된 블록이 잘못 청소될 수 있기 때문에 작업 도중에는 프리 리스트를 잠근다.

## G1

G1은 오라클에서 **자바 9**부터 디폴트 수집기가 된 GC이다. 처음부터 중단 시간이 짧은 새로운 수집기로 설계된 G1은 다음과 같은 특성이 있다. 

- **CMS보다 훨씬 튜닝하기 쉽다.**
- **조기 승격에 덜 취약하다.**
- **대용량 힙에서 확장성이 우수하다.**
- **풀 STW 수집을 없앨 수 있다**

확실히 지금까지 나온 단점들을 모두 해결하는 GC인데. 어떻게 설계된 건지 확인해보자.

### 1) G1 힙 레이아웃 및 영역

G1은 각 힙을 Region 별로 나눈다. 그리고 가비지만 있는 Region을 먼저 회수한다고 해서 Garbage First 라고 한다.

이 영역의 크기는 설정할 수 있는데. 일반적으로 2MB 이다. 그래서 영역의 개수는 힙 크기 / 영역 크기로 구할 수 있다.

각 **Eden, Survivor, Humongous, Old** 영역으로 나눌 수 있는데. Eden, Survivor는 이전에도 언급을 했고 Humongous 는 Region의 절반 이상의 크기인 큰 객체가 저장된다. 

**G1 GC는 워밍업을 하는 동안 GC 사이클을 돌면서 일반 영역의 가비지 비율을 수집한다.**

- **위밍업** : 처음에는 각 영역의 가비지 비율을 알 수 없다. GC 사이클을 돌면서 각 영역의 가비지 비율을 추정하는 단계인데. 약 5 ~ 15분 정도 소요된다.

또 각 영역은 연속되어 있지 않은데 이게 무슨 이점이 있을까? 

- 큰 영역이 아닌 작은 영역으로 나뉘었기 때문에 가비지 비율이 높은 순으로 병렬로 수집이 가능해진다.
- 영역이 작을 수록 중단 시간이 줄어든다.
- 만약 중단 시간이 길면 영역의 크기를 줄인다. 영역의 크기가 작을 수록 중단 시간이 줄어든다.

수집한 수치들은 **Rset**에 저장되는데. Rest은 **부유 가비지**를 해결하는데 유용하다.

- 부유 가비지란, Old 영역에서 Young 영역을 참조한 후 Young 영역의 참조 끊기면 Young GC로는 수집이 되지 않는다. 결국 Old GC가 발생할 때까지 기다려야 하는데. 속도도 느리고 비효율이다. Rset은 이러한 영역간의 참조를 추적하기 때문에 이를 해결할 수 있다.

### 2) G1 수집 단계

- **초기 마킹(STW)**: 가비지 컬렉션을 시작하기 전에, GC 루트(root)로부터 참조되는 모든 객체를 표시(mark)하는 단계입니다. 이 때, 모든 애플리케이션 스레드가 정지(STW)합니다.
- **동시 루트 탐색**: 초기 마킹이 끝나면, 애플리케이션 스레드가 다시 실행되면서 GC 스레드가 동시에 루트 객체들을 탐색하고, 그들이 참조하는 객체들을 표시하는 단계입니다.
- **동시 마킹**: 동시 루트 탐색이 끝나면, GC 스레드가 루트 객체들이 참조하는 객체들을 재귀적으로 탐색하고 표시하는 단계입니다. 이 때도 애플리케이션 스레드가 동시에 실행됩니다.
- **재마킹(STW)**: 동시 마킹이 끝나면, 애플리케이션 스레드가 다시 정지하고, GC 스레드가 동시 마킹 도중에 변경된 객체들을 다시 표시하는 단계입니다. 이 단계는 동시 마킹보다 짧은 시간이 소요됩니다.
- **정리(STW)**: 재마킹이 끝나면, GC 스레드가 각 영역의 가비지 비율을 계산하고, 가비지 비율이 높은 순서대로 수집 대상 영역을 선정합니다. 그리고 수집 대상 영역에서 살아남은 객체들을 다른 영역으로 이동하고, 수집 대상 영역을 비우는 단계입니다. 이 때도 애플리케이션 스레드가 정지합니다.