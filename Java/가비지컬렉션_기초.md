## GC 루트 및 아레나

**GC 루트**는 메모리의 고정점(anchor point)으로 가비지 컬렉션에 회수되지 않는 영역이다. 메모리 풀 외부에서 내부를 가리키는 외부 포인터이다. 

**GC 루트 종류**

- 스택 프레임
- JNI
- 레지스터
- 코드 루트
- 전역 객체
- 로드된 클래스의 메타데이터

**핫스팟**은 자바 가상 머신(JVM)의 구현체 중 하나로, 운영체제로부터 힙을 관리하기 위한 메모리를 할당받고 그 안에서 객체를 관리한다. 그렇기 때문에 객체의 생성과 같은 일을 운영체제에게 요청하는 시스템 콜을 하지 않는다. 또 힙을 유저 공간 영역에서 직접 관리하기 때문에 측정값을 이용해서 GC 서브시스템이 어떤 성능 문제를 일으키고 있는지 파악할 수 있다. 

### 할당과 수명

자바 애플리케이션에서 가비지 수집이 일어나는 주된 원인은 두 가지이다. 

- 할당률
- 객체 수명

할당률이란 객체가 사용한 메모리의 사용량을 말한다. 객체 수명은 측정하기 어렵기 때문에 할당률이 보다 더 핵심적인 요인이다. 

가비지 수집이란 ‘**메모리를 회수해 재사용**’하는 일이다.

### Old & Young

자바의 객체를 보면 대부분의 객체가 단명하고 소수의 객체는 오래 남는다. 그렇기 때문에 빨리 죽는 객체는 빠르게 수집하여 다시 할당할 수 있도록 어린 객체와 늙은 객체를 분리한다. 

핫스팟은 다음과 같은 과정을 거친다. 

- 객체마다 지금까지 통과한 가비지 수집 횟수를 센다
- 수집 횟수가 큰 객체를 제외한 나머지를 에덴으로 옮긴긴다.
- 오래 살아남은 객체는 올드 혹은 테뉴어드로 옮긴다.

Young은 Eden과 Survivor로 나뉠 수 있는데. Eden에는 막 태어난 객체가 들어가고 여기서 살아나면 Survivor로 옮겨진다.

### 카드 테이블

핫스팟은 카트 테이블(card table)이라는 자료 구조에 늙은 객체가 젊은 객체를 참조하는 정보를 기록한다. 카드 테이블은 JVM에서 관리하는 바이트 배열로, 각 원소는 올드 세대 공간의 512바이트 영역을 가리킨다.

또 카드 테이블은 **늙은 세대의 객체들이 젊은 세대를 참조**하는 정보를 담고있다.  

예를 들어, 늙은 객체 o가 참조하는 필드값이 바뀌게 되면 o에 해당하는 instanceOop가 들어 있는 카드를 찾아 엔트리를 **dirty 마킹** 한다. 

dirty 마킹이란, 올드 객체가 가지고 있던 카드를 0으로 바꾸는 행위인데. 이렇게 0으로 바꾸면 늙은 세대가 참조하는 젊은 객체 중에 0으로 표신된 것만 회수하면 되기 때문에 젊은 세대의 빠른 가비지 컬렉션을 보장한다. 

## 핫스팟의 가비지 수집

프로세스가 시작되면 JVM은 메모리를 할당하고 유저 공간에서 연속된 메모리 풀을 관리한다. 객체는 보통 에덴에 생성되는데. 이 객체가 차지한 주소는 빈번하게 바뀐다. 이렇게 객체를 이동시키는 것을 ‘방출’ 이라고 하는데. 핫스팟 수집기는 대부분 방출 수집기다.

### 스레드 로컬 할당

JVM은 에덴을 여러 개의 버퍼로 나눠서 각 애플리케이션 스레드가 새 객체를 할당하는 구역으로 활동하도록 배포한다. 만약 새로운 스레드가 생기면 새로운 에덴 공간을 가지된다. 그렇기 때문에 객체 할당이 겹치지 않을까 걱정할 필요가 없다. 

이렇게 나눠주는 버퍼 구역의 이름을 **스레드 로컬 할당 버퍼(TLAB)** 라고 한다. 만약 할당된 버퍼를 모두 사용하면 새 에덴 영역를 할당받는다.

### 반구형 수집기

반구형 수집기는 JVM에서 사용하는 가비지 컬랙션 알고리즘 중 하나이다. Young 영역은 에덴, 서바이버 0, 서바이버 2로 구성되어 있다. 서바이버 0, 서바이버 1 이 두 개가 필요한 이유는 뭘까? 

먼저 에덴에는 새로운 객체가 생성된다. 한 차례의 GC가 지나고 살아남은 객체는 서바이버 0으로 옮겨진다. 그리고 다시 살아남은 객체는 서바이버 1로 옮겨진다.

이번에는 조금 다르게 다음 GC 때 살아남은 객체는 서바이버 1로 옮겨진다. 그리고 다시 살아남은 객체는 서바이버 0으로 옮겨진다. 

가비지 컬렉션으로부터 특정 횟수 이상 살아남은 객체는 테뉴어드로 옮겨진다. 

## 병렬 수집기

자바 8 이전까지는 JVM 디폴트 가비지 수집기는 병렬 수집기였다. 애플리케이션 스레드를 모두 중단시킨 다음, 가용 CPU 코어를 총돈해 가능한 한 재빨리 메모리를 수집한다. 

### 영 세대 병렬 수집(Parallel GC)

스레드가 에덴에 객체를 할당 받으려는데. **TLAB** 의 공간이 다 차서 JVM에게 새로운 **TLAB** 공간을 할당을 요청한다. 이때 더이상 할당해 줄 공간이 없을 때. 모든 스레드의 동작을 멈추고 영 세대 수집에 들어간다. 

- 에덴에 살아있는 객체를 모두 확인하고 마킹한다.
- 마킹된 객체를 서바이버로 옮긴 후, 세대 카운트를 늘려 한 차례 이동했음을 기록한다.
- 에덴에 남아 있는 공간을 재사용 가능한 빈 공간으로 표시한다.
- TLAB를 할당한다.

### 올드 세대 병렬 수집(ParallelOld GC)

올드 세대는 영 세대와 약간 다르다. 수집되는 것은 같으나 그 방식이 차이가 있는데. 

- 올드 세대가 참조하고 있는 객체가 살아있는 지 확인하며 살아있으면 마킹한다.
- 죽어있는 객체의 공간을 모두 회수한다.
- 살아있는 객체를 힙의 앞쪽으로 이동시키며 재배치한다(압축)